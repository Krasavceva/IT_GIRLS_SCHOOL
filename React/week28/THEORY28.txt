1. Кратко опишите основные отличия state от props. 
Props нельзя изменить внутри компонента, они всегда приходят извне, а state наоборот этим и ценен - можно менять состояние компонента внутри; 
при изменении state происходит новый рендеринг страницы.


2. Какую ошибку я допустила в следующем коде и как ее исправить:
handleChange = () => {
    const chechedArr = this.state.arr; // [1,2,3] 
		chechedArr.push(5); // [1,2,3,5] 
    this.setState({
      arr: chechedArr,
    });
  };
Нельзя напрямую изменить состояние компонента, но можно исправить следующим образом:
 handleChange = () => {
     const chechedArr = [...this.state.arr]; // [1,2,3] 
         chechedArr.push(5); // [1,2,3,5] 
     this.setState({
       arr: chechedArr,
     });
   };


3. Можно ли повесить на один элемент несколько обработчиков событий?
Можно


4. Каким образом можно изменить `state`?
С помощью обработчика событий, который вызовет метод setState():
 class Toggle extends React.Component {
   constructor(props) {
     super(props);
     this.state = {isToggleOn: true};
 
     // Эта привязка обязательна для работы this в колбэке.
     this.handleClick = this.handleClick.bind(this);
   }
 
   handleClick() {
     this.setState(prevState => ({
       isToggleOn: !prevState.isToggleOn
     }));
   }
 
   render() {
     return (
       <button onClick={this.handleClick}>
         {this.state.isToggleOn ? 'Включено' : 'Выключено'}
       </button>
     );
   }
 }



5. Попробуйте предсказать какие сообщения будут в консоли и объяснить результат:
handleChange = () => {
    console.log(this.state.checked) //#1 false 
    this.setState({
      checked: !this.state.checked, //true
    });
    console.log(this.state.checked) //#2 ?
  };  
Будет false и false. setState - асинхронная функция, она выполнится после log.


6. Какими способами можно задать функцию `handleChange` и какой из них является самым правильным?
Если мы работаем с классом, то логично было бы использовать такой стиль определения:
 handleChange() {    
 const { checked } = this.state;    
 this.setState({ checked: !checked });  
 };
Но такой подход плохо работает в React по двум причинам:1) У обычных и стрелочных функций по-разному определяется this. 
С таким определением придется постоянно писать подобный код:
onClick={this.handleClick.bind(this)}/***
 или так ***/onClick={() => this.handleClick()}
Оба предыдущих примера передачи обработчика порождают при каждом вызове функции render новые обработчики, что негативно сказывается на производительности. 
Поэтому правильный способ определения - стрелочная функция:
 handleClick = () => {
 const text = 'Hello world!';    
 this.setState({ text }); 
 };
или
 const [checked, setChecked] = useState(props.checked || false);
 const handleChange = () => {        
 setChecked(!checked);    
 }; // для функционального компонента


7. Чем отличаются классовые и функциональные компоненты? Какие из них предпочтительнее в 2021 году?
 - Главное отличие классового компонента от функционального это возможность хранить внутреннее состояния.
 - Начальное состояние, с которым будет инициализирован компонент после отрисовки, определяется в методе constructor().
 - Для работы this в callback обязательна привязка bind.
 - Классовый компонент должен содержать метод render() (у функционального есть только return), который возвращает React-элемент.
 - Доступ к props осуществляется через this. props.
 - Захват состояния — также одно из фундаментальных различий классовых и функциональных компонентов.
Оно заключается в том, что функциональные компоненты захватывают отрендеренные значения.


8. Есть ли `this` в функциональных компонентах? Как можно получить к нему доступ?
В функциональном компоненте нам недоступен this, поэтому мы не можем задать или считать состояние через this.state. 
Но мы можем менять состояние с помощью setState.


9. Можно ли использовать `props` и `state` одновременно?
Да, они независимы друг от друга.


10. Где можно задать `state` без использования команды `this.setState`?
На этапе инициализации


11. Может ли состояние классового компонента не быть объектом?
    Нет.
А функционального?
    В отличие от случая с классами, состояние может быть не объектом, а строкой или числом, если нам так удобно.


12. Способны ли функциональные компоненты самостоятельно хранить состояние?
С приходом хуков, у функциональных компонентов появилась возможность хранить состояния, 
использовать методы жизненного цикла, и быть полноценными конкурентами классовых.


13. Как использовать хуки в классовых компонентах?
Хуки не работают внутри классов, а используются вместо них.


14. А как задать начальное состояние `props`, если они еще не были переданы?
В React предусмотрен способ устанавливать значения пропсов по умолчанию — defaultProps.
 export default class Button extends React.Component {
     static defaultProps = {
         name: 'Hello!',
     };
     render() {
         const {name, ...props} = this.props;
         return (
             <button {...props}>
                 {name}
             </button>
         );
     }
 }

